<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="../nomad_coders/general_style.css" />
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Intermediate Python</title>
  </head>
  <body>
    <header>
      <a href="course_list.html">뒤로 가기</a>
    </header>
    <h1>Intermediate Python</h1>
    <div id="course0">
      <h2>0. Matplotlib</h2>
      <div id="course0-0" class="idv_class">
        <h3>0-0. Basic plots with Matplotlib</h3>
        <ul>
          <li>
            Matplotlib
            <ul>
              <li>
                <code
                  >import matplotlib.pyplot as plt<br />year = [1950, 1960,
                  1970, 1980]<br />pop = [2.519, 3.692, 5.263, 6.972]<br />plt.<mark>plot</mark>(year,
                  pop)</code
                >
                #tells Python what to plot and how to plot it<code
                  ><br />plt.show()</code
                ><br /><img src="intermediate0.png" height="150px" />
              </li>
            </ul>
          </li>
          <li>
            Scatter plot
            <ul>
              <li>
                <code
                  >import matplotlib.pyplot as plt<br />year = [1950, 1960,
                  1970, 1980]<br />pop = [2.519, 3.692, 5.263, 6.972]<br />plt.<mark>scatter</mark>(year,
                  pop)<br />plt.show()</code
                ><br /><img src="intermediate1.png" height="150px" />
              </li>
            </ul>
          </li>
          <li>
            to put the x-axis on a logarithmic scale
            <ul>
              <li>
                <code
                  >plt.scatter(gdp_cap, life_exp)<br /><mark
                    >plt.xscale('log')</mark
                  ><br />plt.show()</code
                >
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course0-1" class="idv_class">
        <h3>0-1. Histogram</h3>
        <ul>
          <li>
            Histogram
            <ul>
              <li>Explore dataset</li>
              <li>Get idea about distribution</li>
              <li>default number of bins: 10</li>
            </ul>
          </li>
          <li>
            Matplotlib example
            <ul>
              <li>
                <code
                  >import matplotlib.pyplot as plt<br />help(plt.hist)<br />values
                  = [0, 0.6, 1.4, 1.6, 2.2, 2.5, 2.6, 3.2, 3.5, 3.9, 4.2, 6]<br />plt.hist(values,
                  bins=3)<br />plt.show()</code
                ><br /><img src="intermediate2.png" height="150px" />
              </li>
            </ul>
          </li>
          <li>
            example: Population pyramid
            <ul>
              <img src="intermediate3.png" height="260px" />
            </ul>
          </li>
          <li>
            <code><b>plt.show()</b></code
            >: displays a plot
          </li>
          <li>
            <code><b>plt.clf()</b></code
            >: cleans it up so you can start afresh.
          </li>
        </ul>
      </div>
      <div id="course0-2" class="idv_class">
        <h3>0-2. Customization</h3>
        <ul>
          <li>
            Data visualization
            <ul>
              <li>
                Many options
                <ul>
                  <li>Different plot types</li>
                  <li>Many customizations</li>
                </ul>
              </li>
              <li>
                Choice depends on
                <ul>
                  <li>Data</li>
                  <li>Sotry you want to tell</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Axis labels, Title, Ticks, ...
            <ul>
              <li>
                <code
                  >import matplotlib.pyplot as plt<br />year = [1950, 1951,
                  1952, ... ,2100]<br />pop =[2.538, 2.57, 2.62, ... ,10.85]<br /><br />plt.plot(year,
                  pop)<br /><br />#Add more data<br />year = [1800, 1850,
                  1900]+year<br />pop = [1.0, 1.262, 1.650]+pop<br /><br />plt.xlabel('Year')<br />plt.ylabel('Population')<br />plt.title('World
                  Population Proejction')<br /><mark
                    >plt.yticks([0, 2, 4, 6, 8, 10], ['0', '2B', '4B', '6B',
                    '8B', '10B'])</mark
                  ><br /><br />plt.show()</code
                >
              </li>
            </ul>
          </li>
          <li>
            scatter plot에서 bubble size 옵션
            <ul>
              <li>
                <code
                  >plt.scatter(gdp_cap, life_exp, <mark>size=pop</mark>)</code
                ><br /><img src="intermediate4.png" height="250px" />
              </li>
            </ul>
          </li>
          <li>
            np.array(): creates a numpy array from the list
            <ul>
              <li><code>np_pop = np.array(pop)</code></li>
              <li>
                <code>np_pop * 2</code> -> each array element will be doubled
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    <div id="course1">
      <h2>1. Dictionaries & Pandas</h2>
      <div id="course1-0" class="idv_class">
        <h3>1-0. Dictionaries, Part1</h3>
        <ul>
          <li>
            List
            <ul>
              <li>
                <code
                  >pop = [30.55, 2.77, 39.21]<br />countries = ["afghanistan",
                  "albania", "algeria"]<br />ind_alb =
                  countries.index("albania")<br />ind_alb #1<br />pop[ind_alb]
                  #2.77</code
                >
              </li>
            </ul>
          </li>
          <li>
            Dictionary
            <ul>
              <li>
                <code
                  >world = {"afghanistan":30.55, "albania":2.77,
                  "algeria":39.21}<br />world["albania"] #2.77</code
                >
              </li>
              <li>
                Python can make the lookup of these keys very fast, even for
                huge dictionaries
              </li>
              <li>Dictionaries are inherently unordered.</li>
            </ul>
          </li>
          <li>
            print out the keys in a dictionary
            <ul>
              <li><code>print(world<mark>.keys()</mark>)</code></li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course1-1" class="idv_class">
        <h3>1-1. Dictionaries, Part2</h3>
        <ul>
          <li>
            The last pair specified will be kept in the resulting dictionary
            <ul>
              <li>
                <code
                  >dict_ex = {'a':1, 'a':2}<br />print(dict_ex) #{'a':2}</code
                >
              </li>
            </ul>
          </li>
          <li>
            Recap
            <ul>
              <li>
                Keys have to be "immutable" objects
                <ul>
                  <li>ex. strings, booleans, integers, floats</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Add a new key-value pair to a dictionary
            <ul>
              <li>
                <code
                  >world["sealand"] = 0.000027<br />"sealand" in world
                  #True</code
                >
              </li>
            </ul>
          </li>
          <li>
            Change values
            <ul>
              <li><code>world["sealand"] = 0.000028</code></li>
            </ul>
          </li>
          <li>
            Remove a key-value pair
            <ul>
              <li>
                <code><mark>del(</mark>world["sealand"])</code>
              </li>
            </ul>
          </li>
          <li>
            List vs. Dictionary
            <ul>
              <img src="intermediate5.png" height="150px" />
            </ul>
          </li>
        </ul>
      </div>
      <div id="course1-2" class="idv_class">
        <h3>1-2. Pandas, Part1</h3>
        <ul>
          <li>
            Pandas
            <ul>
              <li>High level data manipulation tool</li>
              <li>created by Wes McKinney</li>
              <li>Built on NumPy</li>
              <li>In 2D NumPy arrays, columns can't have different types</li>
              <li>de facto standard for dataset manipulation.</li>
            </ul>
          </li>
          <li>
            DataFrame from Dictionary
            <ul>
              <li>
                <code
                  >dict = {"country":["Brazil", "Russia", "India", "China",
                  "South Africa"], "capital":["Brasilia", "Moscow", "New Delhi",
                  "Beijing", "Pretoria"]}<br />import pandas as pd<br />brics =
                  pd.DataFrame(dict)<br />brics.index = ["BR", "RU", "IN", "CH",
                  "SA"]</code
                >
              </li>
              <li>
                <code
                  >brics = pd.read_csv("path/to/brics.csv",
                  <mark>index_col = 0</mark>)<br
                /></code>
                #index_col -> the first column contains the row indexes
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course1-3" class="idv_class">
        <h3>1-3. Pandas, Part2</h3>
        <ul>
          <li>
            Index and select data
            <ul>
              <li>Square brackets</li>
              <li>
                Advanced methods
                <ul>
                  <li>loc</li>
                  <li>iloc</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Column Access []
            <ul>
              <li>
                <code
                  >brics["country"]<br />type(brics["country"])
                  #pandas.core.series.Series</code
                >
              </li>
              <li>cf. Series: a 1-dimensional array that can be labeled</li>
              <li>
                <code
                  >type(brisc[["country"]]) #pandas.core.frame.DataFrame<br />brics[["country",
                  "capital"]]</code
                >
              </li>
            </ul>
          </li>
          <li>
            To select rows from a DataFrame
            <ul>
              <li>
                <code
                  >brics[1:4] #to get the second, third and fourth rows</code
                >
              </li>
            </ul>
          </li>
          <li>
            Discussion []
            <ul>
              <li>Square bracket: limited functionality</li>
              <li>
                Ideally
                <ul>
                  <li>2D NumPy arrays</li>
                  <li>
                    <code>my_array<mark>[rows, columns]</mark></code>
                  </li>
                </ul>
              </li>
              <li>
                pandas
                <ul>
                  <li><mark>loc (label-based)</mark></li>
                  <li><mark>iloc (integer position-based)</mark></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Row Access loc
            <ul>
              <li>
                <code>brics.loc<mark>["RU"]</mark></code>
              </li>
              <img src="intermediate6.png" height="100px" /><br />result: Series
              <li>
                <code>brics.loc<mark>[["RU"]]</mark></code>
              </li>
              <img src="intermediate7.png" height="45px" /><br />result:
              DataFrame
              <li><code>brics.loc[["RU", "IN", "CH"]]</code></li>
            </ul>
          </li>
          <li>
            Row & Column loc
            <ul>
              <li>
                <code
                  >brics.loc[["RU", "IN", "CH"], ["country", "capital"]]</code
                >
              </li>
              <img src="intermediate8.png" height="85px" />
              <li>
                <code
                  >brics.loc[:, ["country", "capital"]] #select all rows, 2
                  columns</code
                >
              </li>
            </ul>
          </li>
          <li>
            Recap
            <ul>
              <li>
                Square brackets
                <ul>
                  <li>
                    Column access: <code>brics[["country", "capital"]]</code>
                  </li>
                  <li>
                    Row access: only through slicing - <code>brics[1:4]</code>
                  </li>
                </ul>
              </li>
              <li>
                loc (label-based)
                <ul>
                  <li>
                    Row access: <code>brics.loc[["RU", "IN", "CH"]]</code>
                  </li>
                  <li>
                    Column access:
                    <code>brics.loc[:, ["country", "capital"]]</code>
                  </li>
                  <li>
                    Row & Column access:<br />
                    <code
                      >brics.loc[["RU", "IN", "CH"], ["country",
                      "capital"]]</code
                    >
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            If you want to subset Pandas DataFrames based on their position, or
            index, you'll need the iloc function.
          </li>
          <li>
            Row Access iloc
            <ul>
              <li>
                <code
                  >brics.iloc[[1]] #return the second row<br />brics.iloc[[1,2,3]]<br />brics.iloc[[1,2,3],
                  [0,1]]<br />brics.iloc[:, [0,1]]</code
                >
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    <div id="course2">
      <h2>2. Logic, Control Flow and Filtering</h2>
      <div id="course2-0" class="idv_class">
        <h3>2-0. Comparison Operators</h3>
        <ul>
          <li>
            Other comparisons
            <ul>
              <li>
                ex. <code>"carl" < "chris"</code> #True. According to the
                alphabet, carl comes before chris.
              </li>
              <li>cf. <code>3 < "chris"</code> #TypeError</li>
              <li>
                For string comparison, Python determines the relationship based
                on alphabetical order.
              </li>
            </ul>
          </li>
          <li>
            cf. a boolean is a special kind of integer:
            <code>True</code> corresponds to 1, <code>False</code> corresponds
            to 0
          </li>
        </ul>
      </div>
      <div id="course2-1" class="idv_class">
        <h3>2-1. Boolean Operators</h3>
        <ul>
          <li>
            and
            <ul>
              <li>
                <code>True and True #True</code><br /><code
                  >False and True #False</code
                >
              </li>
            </ul>
          </li>
          <li>
            or
            <ul>
              <li>
                <code
                  >True or True #True<br />Flase or True #True<br />False or
                  False #False</code
                >
              </li>
            </ul>
          </li>
          <li>
            not
            <ul>
              <li>
                <code>not True #False<br />not False #True</code>
              </li>
              <li>
                <b>not</b> has a higher priority than <b>and</b> and <b>or</b>,
                it is executed first.
              </li>
            </ul>
          </li>
          <li>
            NumPy
            <ul>
              <li><code>bmi > 21 and bmi < 22 #ValueError</code></li>
              <li>
                <code><mark>logical_and()</mark></code>
                <ul>
                  <li>ex. <code>np.logical_and(bmi>21, bmi<22)</code></li>
                  <li>ex. <code>bmi[np.logical_and(bmi>21, bmi<22)]</code></li>
                </ul>
              </li>
              <li>
                <code><mark>logical_or()</mark></code>
              </li>
              <li>
                <code><mark>logical_not()</mark></code>
              </li>
              <li>
                cf. comparison operators(<, >=, ...) work with NumPy arrays
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course2-2" class="idv_class">
        <h3>2-2. if, elif, else</h3>
        <ul>
          <li>Conditional statements: if, else, elif</li>
        </ul>
      </div>
      <div id="course2-3" class="idv_class">
        <h3>2-3. Filtering Pandas DataFrames</h3>
        <ul>
          <li>
            Select countries with area over 8 million km2
            <ul>
              <li><code>brics[brics["area"] > 8]</code></li>
            </ul>
          </li>
          <li>
            Boolean operators
            <ul>
              <li>
                <code
                  >import numpy as np<br />brics[np.logical_and(brics["area"]>8,
                  brics["area"]<10)]</code
                >
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    <div id="course3">
      <h2>3. Loops</h2>
      <div id="course3-0" class="idv_class">
        <h3>3-0. while loop</h3>
        <ul>
          <li>
            While loop = repeated if statement
            <ul>
              <li>Numerically calculating model</li>
              <li>"repeating action until condition is met"</li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course3-1" class="idv_class">
        <h3>3-1. for loop</h3>
        <ul>
          <li>
            ex.
            <code
              >fam = [1.73, 1.68, 1.71, 1.89]<br />for height in fam:
              <ul>
                print(height)
              </ul></code
            >
          </li>
          <li>
            If you want index value as well -> <b>enumerate</b>
            <ul>
              <li>
                <code
                  >fam = [1.73, 1.68, 1.71, 1.89]<br />for index, height in
                  enumerate(fam):
                  <ul>
                    print("index "+str(index)+": "+str(height))
                  </ul></code
                >
              </li>
            </ul>
          </li>
          <li>
            Loop over string
            <ul>
              <li>
                <code
                  >for c in "family":
                  <ul>
                    print(c.capitalize())
                  </ul></code
                >
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course3-2" class="idv_class">
        <h3>3-2. Loop Data Structures Part 1</h3>
        <ul>
          <li>
            Dictionary
            <ul>
              <li>
                <code
                  >world = {"afghanistan":30.55, "albania":2.77,
                  "algeria":39.21}<br />for key, values in
                  <mark>world.items()</mark>: <u>#method</u>
                  <ul>
                    print(key + "--" + str(value))
                  </ul></code
                >
              </li>
              <li>
                cf. dictionaries are inherently unordered -> the order in which
                they're iterated over is not fixed.
              </li>
              <li></li>
            </ul>
          </li>
          <li>
            2D NumPy arrays
            <ul>
              <li>
                <code
                  >import numpy as np<br />np_height = np.array([1.73, 1.68,
                  1.71, 1.89, 1.79])<br />np_weight = np.array([65.4, 59.2,
                  63.6, 88.4, 68.7])<br />meas = np.array([np_height,
                  np_weight])<br />for val in np.<mark>nditer</mark>(meas):
                  <u>#function</u>
                  <ul>
                    print(val) #we get 10 printouts (first all the height, then
                    all the weights)
                  </ul></code
                >
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course3-3" class="idv_class">
        <h3>3-3. Loop Data Structures Part 2</h3>
        <ul>
          <li>
            in pandas DataFrame - <b>iterrows</b>
            <ul>
              <li>
                the row data that's generated by iterrows() on every run is a
                Pandas Series.
              </li>
              <li>
                not very efficient - on every iteration, you're creating a new
                Pandas Series.
              </li>
              <li>
                <code
                  >import pandas as pd<br />brics = pd.read_csv("brics.csv",
                  index_col = 0)<br />for lab, row in
                  brics.<mark>iterrows()</mark>:
                  <ul>
                    print(lab)<br />print(row)
                  </ul></code
                ><br />
                <ul>
                  <img src="intermediate9.png" height="200px" />
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Selective print
            <ul>
              <li>
                <code
                  >for lab, row in brics.iterrows():
                  <ul>
                    print(lab+": "+row["capital"])
                  </ul></code
                >
              </li>
            </ul>
          </li>
          <li>
            Add column
            <ul>
              <li>
                <code
                  >for lab, row in brics.iterrows():
                  <ul>
                    <b>brics.loc[lab, "name_length"] = len(row["country"])</b>
                    #not really efficient
                  </ul></code
                >
              </li>
              <li>
                <code
                  >brics["name_length"] =
                  brics["country"].<mark>apply</mark>(len) <u>#better!</u></code
                >
              </li>
              <li>
                ex. country name 대문자로 바꾼 column 만들기<br />
                <code>
                  cars["COUNTRY"] = cars["country"].<mark
                    >apply(str.upper)</mark
                  >
                </code>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    <div id="course4">
      <h2>4. Case Study: Hacker Statistics</h2>
      <div id="course4-0" class="idv_class">
        <h3>4-0. Random Numbers</h3>
        <ul>
          <li>
            How to solve?
            <ul>
              <li>Analytical</li>
              <li>
                Simulate the process
                <ul>
                  <li>Hacker statistics!</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            Random generators
            <ul>
              <li>
                <code
                  >import numpy as np<br /><mark>np.random.rand()</mark> #create
                  a <u>pseudo-random</u> number in mathematical formula, between
                  0 and 1</code
                >
              </li>
              <li>
                <code
                  ><mark>np.random.seed</mark>(123) #ensures
                  "reproductibility"<br />np.random.rand()
                  #0.6964691855978616<br />np.random.rand()
                  #0.28613933495037946<br />np.random.seed(123)<br />np.random.rand()
                  #0.6964691855978616<br />np.random.rand()
                  #0.28613933495037946</code
                >
              </li>
              <li>cf. pseudo-random: random but consistent</li>
            </ul>
          </li>
          <li>
            Coin toss
            <ul>
              <li>
                <code
                  >import numpy as np<br />np.random.seed(123)<br />coin =
                  np.random.<mark>randint(0,2)</mark> #randomly generate 0 or
                  1<br />print(coin)</code
                >
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course4-1" class="idv_class">
        <h3>4-1. Random Walk</h3>
        <ul>
          <li>
            Heads or Tails
            <ul>
              <li>
                <code
                  >import numpy as np<br />np.random.seed(123)<br />outcomes =
                  []<br />for x in range(10):
                  <ul>
                    coin = np.random.randint(0,2)<br />if coin==0:
                    <ul>
                      outcomes.append("heads")
                    </ul>
                    else:
                    <ul>
                      outcomes.append("tails")
                    </ul>
                  </ul>
                  print(outcomes)</code
                >
              </li>
            </ul>
          </li>
          <li>
            Heads or Tails: Random Walk
            <ul>
              <li>
                <code
                  >tails = [0]<br />for x in range(10):
                  <ul>
                    coin = np.random.randint(0,2)<br />tails.append(tails[x] +
                    coin)
                  </ul>
                  print(tails) #[0,0,1,1,1,1,1,1,2,3,3] the final element tells
                  you how often tails was thrown</code
                >
              </li>
            </ul>
          </li>
          <li>
            max()
            <ul>
              <li>
                ex. to make sure that a variable x never goes below 10 when you
                decrease it,<br /><code>x = max(10, x-1)</code>
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div id="course4-2" class="idv_class">
        <h3>4-2. Distribution</h3>
        <ul>
          <li>
            100 runs
            <ul>
              <li>
                <code
                  >import numpy as np<br />np.random.seed(123)<br />final_tails
                  = []<br />for x in range(100): #if we run more times(10,000
                  for example), the distribution will converge to a bell-shape
                  <ul>
                    tails = [0]<br />for x in range(10):
                    <ul>
                      coin = np.random.randint(0,2)<br />tails.append(tails[-1])
                    </ul>
                  </ul>
                  print(final_tails) #[3, 6, 4, 5, 4, 5, 3, ..., 4,]</code
                >
              </li>
            </ul>
          </li>
          <li>
            visualizing a distribution -> <b>histogram</b>!
            <ul>
              <li>
                <code
                  >import matplotlib.pyplot as plt<br />plt.hist(final_tails,
                  bins=10)<br />plt.show()</code
                >
              </li>
            </ul>
          </li>
          <li>
            To transpose NumPy array
            <ul>
              <li>
                <code>np_aw_t = <mark>np.transpose</mark>(np_aw)</code>
              </li>
            </ul>
          </li>
          <li>Implement clumsiness (0.01% chance of falling down)
              <ul>
                  <li><code>if np.random.rand() <= 0.001: <ul>step = 0</code></li>
              </ul>
          </li>
          
        </ul>
      </div>
    </div>
  </body>
</html>
